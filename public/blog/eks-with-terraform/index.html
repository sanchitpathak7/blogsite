<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>EKS Cluster Provisioning with VPC Configuration using Terraform | Sanchit Pathak</title>
<meta name="keywords" content="">
<meta name="description" content="Terraform&rsquo;s declarative approach allows to describe the infrastructure in a high-level manner where it evaluates the current state of the infrastructure and determines what actions need to be taken to reach the desired state. Also, its idempotent nature means that applying the same configuration multiple times will result in the same end state as applying it once.
In this blog post I am going over how to setup EKS cluster using Terraform including all the pre-requistites of setting up VPC, SG etc.">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/blog/eks-with-terraform/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.7ebdb09b9f353c4beb4b5cd63794ffcaac493ff418014513a5bf79e01c0408dd.css" integrity="sha256-fr2wm581PEvrS1zWN5T/yqxJP/QYAUUTpb954BwECN0=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/blog/eks-with-terraform/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="EKS Cluster Provisioning with VPC Configuration using Terraform" />
<meta property="og:description" content="Terraform&rsquo;s declarative approach allows to describe the infrastructure in a high-level manner where it evaluates the current state of the infrastructure and determines what actions need to be taken to reach the desired state. Also, its idempotent nature means that applying the same configuration multiple times will result in the same end state as applying it once.
In this blog post I am going over how to setup EKS cluster using Terraform including all the pre-requistites of setting up VPC, SG etc." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/blog/eks-with-terraform/" /><meta property="article:section" content="blog" />



<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="EKS Cluster Provisioning with VPC Configuration using Terraform"/>
<meta name="twitter:description" content="Terraform&rsquo;s declarative approach allows to describe the infrastructure in a high-level manner where it evaluates the current state of the infrastructure and determines what actions need to be taken to reach the desired state. Also, its idempotent nature means that applying the same configuration multiple times will result in the same end state as applying it once.
In this blog post I am going over how to setup EKS cluster using Terraform including all the pre-requistites of setting up VPC, SG etc."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blogs",
      "item": "http://localhost:1313/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "EKS Cluster Provisioning with VPC Configuration using Terraform",
      "item": "http://localhost:1313/blog/eks-with-terraform/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "EKS Cluster Provisioning with VPC Configuration using Terraform",
  "name": "EKS Cluster Provisioning with VPC Configuration using Terraform",
  "description": "Terraform\u0026rsquo;s declarative approach allows to describe the infrastructure in a high-level manner where it evaluates the current state of the infrastructure and determines what actions need to be taken to reach the desired state. Also, its idempotent nature means that applying the same configuration multiple times will result in the same end state as applying it once.\nIn this blog post I am going over how to setup EKS cluster using Terraform including all the pre-requistites of setting up VPC, SG etc.",
  "keywords": [
    
  ],
  "articleBody": "Terraform’s declarative approach allows to describe the infrastructure in a high-level manner where it evaluates the current state of the infrastructure and determines what actions need to be taken to reach the desired state. Also, its idempotent nature means that applying the same configuration multiple times will result in the same end state as applying it once.\nIn this blog post I am going over how to setup EKS cluster using Terraform including all the pre-requistites of setting up VPC, SG etc.\nPre-Requisites Install Terraform Install awscli Configure access, secret key and region values for the IAM user using aws configure Provider Terraform has a Amazon Web Services (AWS) provider that is used to interact with the resources supported by AWS. First, we need to configure the provider with the proper credentials.\nConfiguration for the AWS Provider can be derived from several sources, which get applied in the following order:\nParameters in the provider configuration Environment variables Shared credentials files Shared configuration files Container credentials Instance profile credentials and Region In this case, I used the aws configure command to store the credentials in .aws/credentials file locally, thus the Shared credentials files method will get implemented.\nIn a production scenario, the standard method is to use assumed roles or OIDC (OpenID Connect) for authentication with AWS, where the AWS SDKs and CLI typically handle the credential retrieval process.\nprovider.tf terraform { required_providers { aws = { source = \"hashicorp/aws\" version = \"~\u003e 5.0\" } } } Initialization Run terraform init to prepare the working directory for Terraform operations by setting up the necessary dependencies and configurations specified in the Terraform files.\n~/awsproject  terraform init Initializing the backend... Initializing provider plugins... - Finding hashicorp/aws versions matching \"~\u003e 5.0\"... - Installing hashicorp/aws v5.43.0... - Installed hashicorp/aws v5.43.0 (signed by HashiCorp) Terraform has created a lock file .terraform.lock.hcl to record the provider selections it made above. Include this file in your version control repository so that Terraform can guarantee to make the same selections by default when you run \"terraform init\" in the future. Terraform has been successfully initialized! You may now begin working with Terraform. Try running \"terraform plan\" to see any changes that are required for your infrastructure. All Terraform commands should now work. If you ever set or change modules or backend configuration for Terraform, rerun this command to reinitialize your working directory. If you forget, other commands will detect it and remind you to do so if necessary. The file terraform-provider-aws_v5.43.0_x5 is the AWS provider plugin binary used by Terraform to interact with the AWS API and manage AWS resources.\n~/awsproject  ls .terraform/providers/registry.terraform.io/hashicorp/aws/5.43.0/darwin_amd64 total 1033600 -rwxr-xr-x 1 sanchit staff 519433808 Mar 30 09:58 terraform-provider-aws_v5.43.0_x5 Resources vpc.tf file defines the VPC (Virtual Private Cloud) module with details about VPC itself, subnets, nat gateway and any other necessary networking components. With this module structure, you can create a reusable VPC module that can be included in your Terraform configurations for different environments or projects.\nprovider \"aws\" { region = var.aws_region } data \"aws_availability_zones\" \"available_zones\" {} module \"vpc\" { source = \"terraform-aws-modules/vpc/aws\" version = \"5.7.0\" name = \"sanchit-vpc\" cidr = var.vpc_cidr azs = data.aws_availability_zones.available_zones.names private_subnets = var.private_subnets public_subnets = var.public_subnets enable_nat_gateway = true enable_dns_support = true enable_dns_hostnames = true tags = { Terraform = \"true\" Environment = \"dev\" Cluster = var.cluster_name } } security-group.tf file specifies the security groups for the VPC that is referenced in EKS cluster configuration, controlling inbound and outbound traffic to and from the resources.\nresource \"aws_security_group\" \"worker_mgmt\" { name_prefix = \"worker_node_management\" vpc_id = module.vpc.vpc_id } resource \"aws_security_group_rule\" \"worker_mgmt_ingress\" { description = \"allow inbound traffic from eks\" from_port = 0 protocol = \"-1\" to_port = 0 security_group_id = aws_security_group.worker_mgmt.id type = \"ingress\" cidr_blocks = var.ingress_sg_cidr_range } resource \"aws_security_group_rule\" \"worker_mgmt_egress\" { description = \"allow outbound traffic to anywhere\" from_port = 0 protocol = \"-1\" to_port = 0 security_group_id = aws_security_group.worker_mgmt.id type = \"egress\" cidr_blocks = var.egress_sg_cidr_range } eks-cluster.tf file configures the Amazon EKS (Elastic Kubernetes Service) cluster using eks module which includes cluster details, addons, node group and any other EKS-specific settings.\nmodule \"eks\" { source = \"terraform-aws-modules/eks/aws\" version = \"~\u003e20.0\" cluster_name = var.cluster_name cluster_version = var.cluster_version enable_irsa = true tags = { Terraform = \"true\" Environment = \"dev\" Cluster = var.cluster_name } cluster_endpoint_public_access = true cluster_addons = { coredns = { most_recent = true } kube-proxy = { most_recent = true } vpc-cni = { most_recent = true } } vpc_id = module.vpc.vpc_id subnet_ids = module.vpc.private_subnets eks_managed_node_group_defaults = { ami_type = var.ami_type instance_types = var.instance_type vpc_security_group_ids = [aws_security_group.worker_mgmt.id] } eks_managed_node_groups = { node_group = { min_size = var.min_capacity max_size = var.max_capacity desired_size = var.desired_capacity capacity_type = var.capacity_type key_name = var.key_name } } } variables.tf file defines the input variables required for the Terraform configuration in the project.\nvariable \"aws_region\" { default = \"us-east-2\" description = \"AWS Region\" } variable \"vpc_cidr\" { description = \"Default VPC CIDR range\" } variable \"private_subnets\" { type = list(string) description = \"List of private subnet CIDR blocks\" } variable \"public_subnets\" { type = list(string) description = \"List of public subnet CIDR blocks\" } variable \"cluster_name\" { type = string description = \"Name of EKS cluster\" } variable \"cluster_version\" { type = string description = \"Version of EKS cluster\" } variable \"ami_type\" { type = string description = \"The AMI type for worker nodes\" } variable \"instance_type\" { type = list(string) description = \"The instance type for worker nodes\" } variable \"min_capacity\" { type = number description = \"The minimum capacity for the node group\" } variable \"max_capacity\" { type = number description = \"The maximum capacity for the node group\" } variable \"desired_capacity\" { type = number description = \"The desired capacity for the node group\" } variable \"capacity_type\" { type = string description = \"The capacity type for worker nodes\" } variable \"key_name\" { type = string description = \"The key pair name for SSH access\" } variable \"ingress_sg_cidr_range\" { type = list(string) description = \"Ingress Security Group CIDR Allowed range\" } variable \"egress_sg_cidr_range\" { type = list(string) description = \"Ingress Security Group CIDR Allowed range\" } terraform.tfvars file contains the values for the input variables defined in variables.tf, allowing to customize the configuration without modifying the main Terraform files.\n# VPC vpc_cidr = \"10.0.0.0/16\" # Subnets private_subnets = [\"10.0.1.0/24\", \"10.0.2.0/24\"] public_subnets = [\"10.0.6.0/24\", \"10.0.7.0/24\"] # Security Group ingress_sg_cidr_range = [\"10.0.0.0/8\", \"172.16.0.0/12\", \"192.168.0.0/16\"] egress_sg_cidr_range = [\"0.0.0.0/0\"] # EKS cluster_name = \"sanchit-eks\" cluster_version = \"1.29\" ami_type = \"AL2_x86_64\" instance_type = [\"t2.micro\"] min_capacity = 2 max_capacity = 3 desired_capacity = 2 capacity_type = \"SPOT\" key_name = \"sanchit-key\" outputs.tf file is used to define outputs that one wants to expose from the modules or resources.\noutput \"vpc_id\" { value = module.vpc.vpc_id } output \"cluster_id\" { value = module.eks.cluster_id } output \"cluster_endpoint\" { value = module.eks.cluster_endpoint } output \"oidc_provider_arn\" { value = module.eks.oidc_provider_arn } Re-Initialization for the VPC and EKS Modules:\n~/awsproject  terraform init Initializing the backend... Initializing modules... Downloading registry.terraform.io/terraform-aws-modules/vpc/aws 5.7.0 for vpc... - vpc in .terraform/modules/vpc Downloading registry.terraform.io/terraform-aws-modules/eks/aws 20.8.4 for eks... - eks in .terraform/modules/eks - eks.eks_managed_node_group in .terraform/modules/eks/modules/eks-managed-node-group - eks.eks_managed_node_group.user_data in .terraform/modules/eks/modules/_user_data - eks.fargate_profile in .terraform/modules/eks/modules/fargate-profile Downloading registry.terraform.io/terraform-aws-modules/kms/aws 2.1.0 for eks.kms... - eks.kms in .terraform/modules/eks.kms - eks.self_managed_node_group in .terraform/modules/eks/modules/self-managed-node-group - eks.self_managed_node_group.user_data in .terraform/modules/eks/modules/_user_data Initializing provider plugins... - Finding hashicorp/tls versions matching \"\u003e= 3.0.0\"... - Finding hashicorp/time versions matching \"\u003e= 0.9.0\"... - Finding hashicorp/null versions matching \"\u003e= 3.0.0\"... - Finding hashicorp/cloudinit versions matching \"\u003e= 2.0.0\"... - Reusing previous version of hashicorp/aws from the dependency lock file - Installing hashicorp/tls v4.0.5... - Installed hashicorp/tls v4.0.5 (signed by HashiCorp) - Installing hashicorp/time v0.11.1... - Installed hashicorp/time v0.11.1 (signed by HashiCorp) - Installing hashicorp/null v3.2.2... - Installed hashicorp/null v3.2.2 (signed by HashiCorp) - Installing hashicorp/cloudinit v2.3.3... - Installed hashicorp/cloudinit v2.3.3 (signed by HashiCorp) - Using previously-installed hashicorp/aws v5.43.0 Terraform has made some changes to the provider dependency selections recorded in the .terraform.lock.hcl file. Review those changes and commit them to your version control system if they represent changes you intended to make. Terraform has been successfully initialized! Plan (Truncated Output)\n~/awsproject  terraform plan ... Plan: 63 to add, 0 to change, 0 to destroy. Changes to Outputs: + cluster_endpoint = (known after apply) + cluster_id = (known after apply) + oidc_provider_arn = (known after apply) + vpc_id = (known after apply) Apply (Truncated Output)\n~/awsproject  terraform apply ... Do you want to perform these actions? Terraform will perform the actions described above. Only 'yes' will be accepted to approve. Enter a value: yes ... Apply complete! Resources: 63 added, 0 changed, 0 destroyed. Outputs: cluster_endpoint = \"https://167EB04858CCE0855BF0D0DA91DC159C.gr7.us-east-2.eks.amazonaws.com\" oidc_provider_arn = \"arn:aws:iam::211125521645:oidc-provider/oidc.eks.us-east-2.amazonaws.com/id/167EB04858CCE0855BF0D0DA91DC159C\" vpc_id = \"vpc-090f2c6840df227b1\" Validation VPC:\n~/awsproject  aws --region us-east-2 ec2 describe-vpcs --vpc-ids 'vpc-090f2c6840df227b1' { \"Vpcs\": [ { \"CidrBlock\": \"10.0.0.0/16\", \"DhcpOptionsId\": \"dopt-0a1b84a258b357e47\", \"State\": \"available\", \"VpcId\": \"vpc-090f2c6840df227b1\", \"OwnerId\": \"211125521645\", \"InstanceTenancy\": \"default\", \"CidrBlockAssociationSet\": [ { \"AssociationId\": \"vpc-cidr-assoc-010848292ad0321b4\", \"CidrBlock\": \"10.0.0.0/16\", \"CidrBlockState\": { \"State\": \"associated\" } } ], \"IsDefault\": false, \"Tags\": [ { \"Key\": \"Name\", \"Value\": \"sanchit-vpc\" }, { \"Key\": \"Cluster\", \"Value\": \"sanchit-eks\" }, { \"Key\": \"Environment\", \"Value\": \"dev\" }, { \"Key\": \"Terraform\", \"Value\": \"true\" } ] } ] } EKS Cluster:\n~/awsproject  aws --region=us-east-2 eks describe-cluster --name=sanchit-eks { \"cluster\": { \"name\": \"sanchit-eks\", \"arn\": \"arn:aws:eks:us-east-2:211125521645:cluster/sanchit-eks\", \"createdAt\": 1711832940.716, \"version\": \"1.29\", \"endpoint\": \"https://167EB04858CCE0855BF0D0DA91DC159C.gr7.us-east-2.eks.amazonaws.com\", \"roleArn\": \"arn:aws:iam::211125521645:role/sanchit-eks-cluster-20240330210835870900000001\", \"resourcesVpcConfig\": { \"subnetIds\": [ \"subnet-00352605c8be7996d\", \"subnet-03d24ec39d2fa152a\" ], \"securityGroupIds\": [ \"sg-0ab70766a8ec0f71d\" ], \"clusterSecurityGroupId\": \"sg-0a2953c5f02876864\", \"vpcId\": \"vpc-090f2c6840df227b1\", \"endpointPublicAccess\": true, \"endpointPrivateAccess\": true, \"publicAccessCidrs\": [ \"0.0.0.0/0\" ] }, \"kubernetesNetworkConfig\": { \"serviceIpv4Cidr\": \"172.20.0.0/16\", \"ipFamily\": \"ipv4\" }, \"logging\": { \"clusterLogging\": [ { \"types\": [ \"api\", \"audit\", \"authenticator\" ], \"enabled\": true }, { \"types\": [ \"controllerManager\", \"scheduler\" ], \"enabled\": false } ] }, \"identity\": { \"oidc\": { \"issuer\": \"https://oidc.eks.us-east-2.amazonaws.com/id/167EB04858CCE0855BF0D0DA91DC159C\" } }, \"status\": \"ACTIVE\", \"certificateAuthority\": { \"data\": \"\" }, \"platformVersion\": \"eks.5\", \"tags\": { \"Cluster\": \"sanchit-eks\", \"Environment\": \"dev\", \"terraform-aws-modules\": \"eks\", \"Terraform\": \"true\" }, \"encryptionConfig\": [ { \"resources\": [ \"secrets\" ], \"provider\": { \"keyArn\": \"arn:aws:kms:us-east-2:211125521645:key/6cc636b4-13c9-47aa-9fc2-4654a1c0e5ea\" } } ], \"health\": { \"issues\": [] } } } Generate Kubeconfig:\n ~/awsproject  aws --region=us-east-2 eks update-kubeconfig --name=sanchit-eks Added new context arn:aws:eks:us-east-2:211125521645:cluster/sanchit-eks to /Users/sanchit/.kube/config When trying to access the cluster, got error Your current IAM principal doesn't have access to Kubernetes objects on this cluster. This might be due to the current principal not having an IAM access entry with permissions to access the cluster.\nFixed by creating Access Policy AmazonEKSClusterAdminPolicy for the IAM user.\nNow works :)\n~/awsproject  kubectl get nodes NAME STATUS ROLES AGE VERSION ip-10-0-1-100.us-east-2.compute.internal Ready 24m v1.29.0-eks-5e0fdde ip-10-0-2-208.us-east-2.compute.internal Ready 25m v1.29.0-eks-5e0fdde When terraform destroy is run, Terraform will compare the current state of your infrastructure with the desired state described in your Terraform configuration and plan the destruction of any resources that are no longer needed. This can all be done in a YAML-based format as well using EKSCTL. Will explore that in a different blog.\n",
  "wordCount" : "1768",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/blog/eks-with-terraform/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Sanchit Pathak",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Sanchit Pathak (Alt + H)">Sanchit Pathak</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/blog/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      EKS Cluster Provisioning with VPC Configuration using Terraform
    </h1>
    <div class="post-meta">

</div>
  </header> 
  <div class="post-content"><p>Terraform&rsquo;s declarative approach allows to describe the infrastructure in a high-level manner where it evaluates the current state of the infrastructure and determines what actions need to be taken to reach the desired state. Also, its idempotent nature means that applying the same configuration multiple times will result in the same end state as applying it once.</p>
<p>In this blog post I am going over how to setup EKS cluster using Terraform including all the pre-requistites of setting up VPC, SG etc.</p>
<h3 id="pre-requisites">Pre-Requisites<a hidden class="anchor" aria-hidden="true" href="#pre-requisites">#</a></h3>
<ul>
<li><a href="https://developer.hashicorp.com/terraform/tutorials/aws-get-started/install-cli">Install Terraform</a></li>
<li><a href="https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html">Install awscli</a></li>
<li>Configure access, secret key and region values for the IAM user using <code>aws configure</code></li>
</ul>
<h3 id="provider">Provider<a hidden class="anchor" aria-hidden="true" href="#provider">#</a></h3>
<p>Terraform has a Amazon Web Services (AWS) provider that is used to interact with the resources supported by AWS. First, we need to configure the provider with the proper credentials.</p>
<p>Configuration for the AWS Provider can be derived from several sources, which get applied in the following order:</p>
<ul>
<li>Parameters in the provider configuration</li>
<li>Environment variables</li>
<li>Shared credentials files</li>
<li>Shared configuration files</li>
<li>Container credentials</li>
<li>Instance profile credentials and Region</li>
</ul>
<p>In this case, I used the <code>aws configure</code> command to store the credentials in <code>.aws/credentials</code> file locally, thus the <code>Shared credentials files</code> method will get implemented.</p>
<p>In a production scenario, the standard method is to use assumed roles or OIDC (OpenID Connect) for authentication with AWS, where the AWS SDKs and CLI typically handle the credential retrieval process.</p>
<h4 id="providertf">provider.tf<a hidden class="anchor" aria-hidden="true" href="#providertf">#</a></h4>
<pre tabindex="0"><code>terraform {
    required_providers {
        aws = {
            source = &#34;hashicorp/aws&#34;
            version = &#34;~&gt; 5.0&#34;
        }
    }
}
</code></pre><hr>
<h3 id="initialization">Initialization<a hidden class="anchor" aria-hidden="true" href="#initialization">#</a></h3>
<p>Run <code>terraform init</code> to prepare the working directory for Terraform operations by setting up the necessary dependencies and configurations specified in the Terraform files.</p>
<pre tabindex="0"><code>~/awsproject  terraform init

Initializing the backend...

Initializing provider plugins...
- Finding hashicorp/aws versions matching &#34;~&gt; 5.0&#34;...
- Installing hashicorp/aws v5.43.0...
- Installed hashicorp/aws v5.43.0 (signed by HashiCorp)

Terraform has created a lock file .terraform.lock.hcl to record the provider
selections it made above. Include this file in your version control repository
so that Terraform can guarantee to make the same selections by default when
you run &#34;terraform init&#34; in the future.

Terraform has been successfully initialized!

You may now begin working with Terraform. Try running &#34;terraform plan&#34; to see
any changes that are required for your infrastructure. All Terraform commands
should now work.

If you ever set or change modules or backend configuration for Terraform,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.
</code></pre><p>The file <code>terraform-provider-aws_v5.43.0_x5</code> is the AWS provider plugin binary used by Terraform to interact with the AWS API and manage AWS resources.</p>
<pre tabindex="0"><code>~/awsproject  ls .terraform/providers/registry.terraform.io/hashicorp/aws/5.43.0/darwin_amd64
total 1033600
-rwxr-xr-x  1 sanchit  staff  519433808 Mar 30 09:58 terraform-provider-aws_v5.43.0_x5
</code></pre><hr>
<h3 id="resources">Resources<a hidden class="anchor" aria-hidden="true" href="#resources">#</a></h3>
<p><code>vpc.tf</code> file defines the VPC (Virtual Private Cloud) module with details about VPC itself, subnets, nat gateway and any other necessary networking components. With this module structure, you can create a reusable VPC module that can be included in your Terraform configurations for different environments or projects.</p>
<pre tabindex="0"><code>provider &#34;aws&#34; {
    region = var.aws_region
}

data &#34;aws_availability_zones&#34; &#34;available_zones&#34; {}

module &#34;vpc&#34; {
    source = &#34;terraform-aws-modules/vpc/aws&#34;
    version = &#34;5.7.0&#34;

    name                    = &#34;sanchit-vpc&#34;
    cidr                    = var.vpc_cidr
    azs                     = data.aws_availability_zones.available_zones.names
    private_subnets         = var.private_subnets
    public_subnets          = var.public_subnets
    enable_nat_gateway      = true
    enable_dns_support      = true
    enable_dns_hostnames    = true
    tags = {
        Terraform           = &#34;true&#34;
        Environment         = &#34;dev&#34;
        Cluster             = var.cluster_name
    }
}
</code></pre><p><code>security-group.tf</code> file specifies the security groups for the VPC that is referenced in EKS cluster configuration, controlling inbound and outbound traffic to and from the resources.</p>
<pre tabindex="0"><code>resource &#34;aws_security_group&#34; &#34;worker_mgmt&#34; {
  name_prefix = &#34;worker_node_management&#34;
  vpc_id      = module.vpc.vpc_id
}

resource &#34;aws_security_group_rule&#34; &#34;worker_mgmt_ingress&#34; {
    description       = &#34;allow inbound traffic from eks&#34;
    from_port         = 0
    protocol          = &#34;-1&#34;
    to_port           = 0
    security_group_id = aws_security_group.worker_mgmt.id
    type              = &#34;ingress&#34;
    cidr_blocks       = var.ingress_sg_cidr_range
}

resource &#34;aws_security_group_rule&#34; &#34;worker_mgmt_egress&#34; {
    description       = &#34;allow outbound traffic to anywhere&#34;
    from_port         = 0
    protocol          = &#34;-1&#34;
    to_port           = 0
    security_group_id = aws_security_group.worker_mgmt.id
    type              = &#34;egress&#34;
    cidr_blocks       = var.egress_sg_cidr_range
}
</code></pre><p><code>eks-cluster.tf</code> file configures the Amazon EKS (Elastic Kubernetes Service) cluster using eks module which includes cluster details, addons, node group and any other EKS-specific settings.</p>
<pre tabindex="0"><code>module &#34;eks&#34; {
    source = &#34;terraform-aws-modules/eks/aws&#34;
    version = &#34;~&gt;20.0&#34;
    cluster_name = var.cluster_name
    cluster_version = var.cluster_version
    enable_irsa = true
    tags = {
        Terraform   = &#34;true&#34;
        Environment = &#34;dev&#34;
        Cluster     = var.cluster_name
    }

    cluster_endpoint_public_access  = true
    cluster_addons = {
        coredns = {
            most_recent = true
        }
        kube-proxy = {
            most_recent = true
        }
        vpc-cni = {
            most_recent = true
        }
    }

    vpc_id = module.vpc.vpc_id
    subnet_ids = module.vpc.private_subnets

    eks_managed_node_group_defaults = {
        ami_type               = var.ami_type
        instance_types         = var.instance_type
        vpc_security_group_ids = [aws_security_group.worker_mgmt.id]
    }

    eks_managed_node_groups = {
        node_group = {
            min_size      = var.min_capacity
            max_size      = var.max_capacity
            desired_size  = var.desired_capacity
            capacity_type = var.capacity_type
            key_name      = var.key_name
        }
    }
}
</code></pre><p><code>variables.tf</code> file defines the input variables required for the Terraform configuration in the project.</p>
<pre tabindex="0"><code>variable &#34;aws_region&#34; {
    default = &#34;us-east-2&#34;
    description = &#34;AWS Region&#34;
}

variable &#34;vpc_cidr&#34; {
    description = &#34;Default VPC CIDR range&#34;
}

variable &#34;private_subnets&#34; {
    type = list(string)
    description = &#34;List of private subnet CIDR blocks&#34;
}

variable &#34;public_subnets&#34; {
    type = list(string)
    description = &#34;List of public subnet CIDR blocks&#34;
}

variable &#34;cluster_name&#34; {
    type = string
    description = &#34;Name of EKS cluster&#34;
}

variable &#34;cluster_version&#34; {
    type = string
    description = &#34;Version of EKS cluster&#34;
}

variable &#34;ami_type&#34; {
    type = string
    description = &#34;The AMI type for worker nodes&#34;
}

variable &#34;instance_type&#34; {
    type = list(string)
    description = &#34;The instance type for worker nodes&#34;
}

variable &#34;min_capacity&#34; {
    type = number
    description = &#34;The minimum capacity for the node group&#34;
}

variable &#34;max_capacity&#34; {
    type = number
    description = &#34;The maximum capacity for the node group&#34;
}

variable &#34;desired_capacity&#34; {
    type = number
    description = &#34;The desired capacity for the node group&#34;
}

variable &#34;capacity_type&#34; {
    type = string
    description = &#34;The capacity type for worker nodes&#34;
}

variable &#34;key_name&#34; {
    type = string
    description = &#34;The key pair name for SSH access&#34;
}

variable &#34;ingress_sg_cidr_range&#34; {
    type = list(string)
    description = &#34;Ingress Security Group CIDR Allowed range&#34;
}

variable &#34;egress_sg_cidr_range&#34; {
    type = list(string)
    description = &#34;Ingress Security Group CIDR Allowed range&#34;
}
</code></pre><p><code>terraform.tfvars</code> file contains the values for the input variables defined in variables.tf, allowing to customize the configuration without modifying the main Terraform files.</p>
<pre tabindex="0"><code># VPC
vpc_cidr = &#34;10.0.0.0/16&#34;

# Subnets
private_subnets = [&#34;10.0.1.0/24&#34;, &#34;10.0.2.0/24&#34;]
public_subnets  = [&#34;10.0.6.0/24&#34;, &#34;10.0.7.0/24&#34;]

# Security Group
ingress_sg_cidr_range = [&#34;10.0.0.0/8&#34;, &#34;172.16.0.0/12&#34;, &#34;192.168.0.0/16&#34;]
egress_sg_cidr_range  = [&#34;0.0.0.0/0&#34;]

# EKS
cluster_name     = &#34;sanchit-eks&#34;
cluster_version  = &#34;1.29&#34;
ami_type         = &#34;AL2_x86_64&#34;
instance_type    = [&#34;t2.micro&#34;]
min_capacity     = 2
max_capacity     = 3
desired_capacity = 2
capacity_type    = &#34;SPOT&#34;
key_name         = &#34;sanchit-key&#34;
</code></pre><p><code>outputs.tf</code> file is used to define outputs that one wants to expose from the modules or resources.</p>
<pre tabindex="0"><code>output &#34;vpc_id&#34; {
    value = module.vpc.vpc_id
}

output &#34;cluster_id&#34; {
    value = module.eks.cluster_id
}

output &#34;cluster_endpoint&#34; {
  value = module.eks.cluster_endpoint
}

output &#34;oidc_provider_arn&#34; {
  value = module.eks.oidc_provider_arn
}
</code></pre><hr>
<p>Re-Initialization for the VPC and EKS Modules:</p>
<pre tabindex="0"><code>~/awsproject  terraform init

Initializing the backend...
Initializing modules...
Downloading registry.terraform.io/terraform-aws-modules/vpc/aws 5.7.0 for vpc...
- vpc in .terraform/modules/vpc
Downloading registry.terraform.io/terraform-aws-modules/eks/aws 20.8.4 for eks...
- eks in .terraform/modules/eks
- eks.eks_managed_node_group in .terraform/modules/eks/modules/eks-managed-node-group
- eks.eks_managed_node_group.user_data in .terraform/modules/eks/modules/_user_data
- eks.fargate_profile in .terraform/modules/eks/modules/fargate-profile
Downloading registry.terraform.io/terraform-aws-modules/kms/aws 2.1.0 for eks.kms...
- eks.kms in .terraform/modules/eks.kms
- eks.self_managed_node_group in .terraform/modules/eks/modules/self-managed-node-group
- eks.self_managed_node_group.user_data in .terraform/modules/eks/modules/_user_data

Initializing provider plugins...
- Finding hashicorp/tls versions matching &#34;&gt;= 3.0.0&#34;...
- Finding hashicorp/time versions matching &#34;&gt;= 0.9.0&#34;...
- Finding hashicorp/null versions matching &#34;&gt;= 3.0.0&#34;...
- Finding hashicorp/cloudinit versions matching &#34;&gt;= 2.0.0&#34;...
- Reusing previous version of hashicorp/aws from the dependency lock file
- Installing hashicorp/tls v4.0.5...
- Installed hashicorp/tls v4.0.5 (signed by HashiCorp)
- Installing hashicorp/time v0.11.1...
- Installed hashicorp/time v0.11.1 (signed by HashiCorp)
- Installing hashicorp/null v3.2.2...
- Installed hashicorp/null v3.2.2 (signed by HashiCorp)
- Installing hashicorp/cloudinit v2.3.3...
- Installed hashicorp/cloudinit v2.3.3 (signed by HashiCorp)
- Using previously-installed hashicorp/aws v5.43.0

Terraform has made some changes to the provider dependency selections recorded
in the .terraform.lock.hcl file. Review those changes and commit them to your
version control system if they represent changes you intended to make.

Terraform has been successfully initialized!
</code></pre><hr>
<p>Plan (Truncated Output)</p>
<pre tabindex="0"><code>~/awsproject  terraform plan
...
Plan: 63 to add, 0 to change, 0 to destroy.

Changes to Outputs:
  + cluster_endpoint  = (known after apply)
  + cluster_id        = (known after apply)
  + oidc_provider_arn = (known after apply)
  + vpc_id            = (known after apply)
</code></pre><hr>
<p>Apply (Truncated Output)</p>
<pre tabindex="0"><code>~/awsproject  terraform apply
...
Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only &#39;yes&#39; will be accepted to approve.

  Enter a value: yes
...
Apply complete! Resources: 63 added, 0 changed, 0 destroyed.

Outputs:

cluster_endpoint = &#34;https://167EB04858CCE0855BF0D0DA91DC159C.gr7.us-east-2.eks.amazonaws.com&#34;
oidc_provider_arn = &#34;arn:aws:iam::211125521645:oidc-provider/oidc.eks.us-east-2.amazonaws.com/id/167EB04858CCE0855BF0D0DA91DC159C&#34;
vpc_id = &#34;vpc-090f2c6840df227b1&#34;
</code></pre><hr>
<h3 id="validation">Validation<a hidden class="anchor" aria-hidden="true" href="#validation">#</a></h3>
<p>VPC:</p>
<pre tabindex="0"><code>~/awsproject  aws --region us-east-2 ec2 describe-vpcs --vpc-ids &#39;vpc-090f2c6840df227b1&#39; 
{
    &#34;Vpcs&#34;: [
        {
            &#34;CidrBlock&#34;: &#34;10.0.0.0/16&#34;,
            &#34;DhcpOptionsId&#34;: &#34;dopt-0a1b84a258b357e47&#34;,
            &#34;State&#34;: &#34;available&#34;,
            &#34;VpcId&#34;: &#34;vpc-090f2c6840df227b1&#34;,
            &#34;OwnerId&#34;: &#34;211125521645&#34;,
            &#34;InstanceTenancy&#34;: &#34;default&#34;,
            &#34;CidrBlockAssociationSet&#34;: [
                {
                    &#34;AssociationId&#34;: &#34;vpc-cidr-assoc-010848292ad0321b4&#34;,
                    &#34;CidrBlock&#34;: &#34;10.0.0.0/16&#34;,
                    &#34;CidrBlockState&#34;: {
                        &#34;State&#34;: &#34;associated&#34;
                    }
                }
            ],
            &#34;IsDefault&#34;: false,
            &#34;Tags&#34;: [
                {
                    &#34;Key&#34;: &#34;Name&#34;,
                    &#34;Value&#34;: &#34;sanchit-vpc&#34;
                },
                {
                    &#34;Key&#34;: &#34;Cluster&#34;,
                    &#34;Value&#34;: &#34;sanchit-eks&#34;
                },
                {
                    &#34;Key&#34;: &#34;Environment&#34;,
                    &#34;Value&#34;: &#34;dev&#34;
                },
                {
                    &#34;Key&#34;: &#34;Terraform&#34;,
                    &#34;Value&#34;: &#34;true&#34;
                }
            ]
        }
    ]
}
</code></pre><p><img loading="lazy" src="https://github.com/sanchitpathak7/terraform/assets/44384286/958aa794-1319-4ab8-823e-043812e26020" alt="VPC"  />
</p>
<p>EKS Cluster:</p>
<pre tabindex="0"><code>~/awsproject  aws --region=us-east-2 eks describe-cluster --name=sanchit-eks
{
    &#34;cluster&#34;: {
        &#34;name&#34;: &#34;sanchit-eks&#34;,
        &#34;arn&#34;: &#34;arn:aws:eks:us-east-2:211125521645:cluster/sanchit-eks&#34;,
        &#34;createdAt&#34;: 1711832940.716,
        &#34;version&#34;: &#34;1.29&#34;,
        &#34;endpoint&#34;: &#34;https://167EB04858CCE0855BF0D0DA91DC159C.gr7.us-east-2.eks.amazonaws.com&#34;,
        &#34;roleArn&#34;: &#34;arn:aws:iam::211125521645:role/sanchit-eks-cluster-20240330210835870900000001&#34;,
        &#34;resourcesVpcConfig&#34;: {
            &#34;subnetIds&#34;: [
                &#34;subnet-00352605c8be7996d&#34;,
                &#34;subnet-03d24ec39d2fa152a&#34;
            ],
            &#34;securityGroupIds&#34;: [
                &#34;sg-0ab70766a8ec0f71d&#34;
            ],
            &#34;clusterSecurityGroupId&#34;: &#34;sg-0a2953c5f02876864&#34;,
            &#34;vpcId&#34;: &#34;vpc-090f2c6840df227b1&#34;,
            &#34;endpointPublicAccess&#34;: true,
            &#34;endpointPrivateAccess&#34;: true,
            &#34;publicAccessCidrs&#34;: [
                &#34;0.0.0.0/0&#34;
            ]
        },
        &#34;kubernetesNetworkConfig&#34;: {
            &#34;serviceIpv4Cidr&#34;: &#34;172.20.0.0/16&#34;,
            &#34;ipFamily&#34;: &#34;ipv4&#34;
        },
        &#34;logging&#34;: {
            &#34;clusterLogging&#34;: [
                {
                    &#34;types&#34;: [
                        &#34;api&#34;,
                        &#34;audit&#34;,
                        &#34;authenticator&#34;
                    ],
                    &#34;enabled&#34;: true
                },
                {
                    &#34;types&#34;: [
                        &#34;controllerManager&#34;,
                        &#34;scheduler&#34;
                    ],
                    &#34;enabled&#34;: false
                }
            ]
        },
        &#34;identity&#34;: {
            &#34;oidc&#34;: {
                &#34;issuer&#34;: &#34;https://oidc.eks.us-east-2.amazonaws.com/id/167EB04858CCE0855BF0D0DA91DC159C&#34;
            }
        },
        &#34;status&#34;: &#34;ACTIVE&#34;,
        &#34;certificateAuthority&#34;: {
            &#34;data&#34;: &#34;&lt;REDACTED&gt;&#34;
        },
        &#34;platformVersion&#34;: &#34;eks.5&#34;,
        &#34;tags&#34;: {
            &#34;Cluster&#34;: &#34;sanchit-eks&#34;,
            &#34;Environment&#34;: &#34;dev&#34;,
            &#34;terraform-aws-modules&#34;: &#34;eks&#34;,
            &#34;Terraform&#34;: &#34;true&#34;
        },
        &#34;encryptionConfig&#34;: [
            {
                &#34;resources&#34;: [
                    &#34;secrets&#34;
                ],
                &#34;provider&#34;: {
                    &#34;keyArn&#34;: &#34;arn:aws:kms:us-east-2:211125521645:key/6cc636b4-13c9-47aa-9fc2-4654a1c0e5ea&#34;
                }
            }
        ],
        &#34;health&#34;: {
            &#34;issues&#34;: []
        }
    }
}
</code></pre><hr>
<p>Generate Kubeconfig:</p>
<pre tabindex="0"><code> ~/awsproject  aws --region=us-east-2 eks update-kubeconfig --name=sanchit-eks
Added new context arn:aws:eks:us-east-2:211125521645:cluster/sanchit-eks to /Users/sanchit/.kube/config
</code></pre><p>When trying to access the cluster, got error
<code>Your current IAM principal doesn't have access to Kubernetes objects on this cluster. This might be due to the current principal not having an IAM access entry with permissions to access the cluster.</code></p>
<p>Fixed by creating Access Policy AmazonEKSClusterAdminPolicy for the IAM user.</p>
<hr>
<p>Now works :)</p>
<pre tabindex="0"><code>~/awsproject  kubectl get nodes                                                                                       
NAME                                       STATUS   ROLES    AGE   VERSION
ip-10-0-1-100.us-east-2.compute.internal   Ready    &lt;none&gt;   24m   v1.29.0-eks-5e0fdde
ip-10-0-2-208.us-east-2.compute.internal   Ready    &lt;none&gt;   25m   v1.29.0-eks-5e0fdde
</code></pre><hr>
<p>When <code>terraform destroy</code> is run, Terraform will compare the current state of your infrastructure with the desired state described in your Terraform configuration and plan the destruction of any resources that are no longer needed. This can all be done in a YAML-based format as well using <a href="https://eksctl.io/">EKSCTL</a>. Will explore that in a different blog.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/blog/ebs-volume-conversion/">
    <span class="title">« Prev</span>
    <br>
    <span>EBS Volume GP2 to GP3 Conversion using a CloudWatch Events Triggered Lambda Function</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="http://localhost:1313/">Sanchit Pathak</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
